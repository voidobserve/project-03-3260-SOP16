C51 COMPILER V9.60.7.0   RF_LEARN                                                          07/08/2025 17:28:58 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_LEARN
OBJECT MODULE PLACED IN .\Release\Objects\rf_learn.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_learn.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) IN
                    -CDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_learn
                    -.lst) OBJECT(.\Release\Objects\rf_learn.obj)

line level    source

   1          // Ñ§Ï°¹¦ÄÜ£¨±£´æÆ÷¼şµØÖ·Ïà¹Ø£©µÄÔ´ÎÄ¼ş
   2          #include "rf_learn.h" //
   3          #include "flash.h"    // °üº¬µ¥Æ¬»úµÄflashÏà¹Ø²Ù×÷
   4          #include "rf_recv.h"  // rf½âÂëÏà¹Ø²Ù×÷
   5          #include "send_key.h" // ·¢ËÍ¼üÖµ£¬²âÊÔÊ±ÓÃ
   6          #include "tmr2.h"     // Ê¹ÓÃ¶¨Ê±Æ÷TMR2À´ÊµÏÖ5sÑÓÊ±
   7          
   8          #include "stimer0.h"
   9          
  10          #include <stdlib.h> // Ê¹ÓÃÁËNULL
  11          
  12          addr_info_t addr_info = {0}; // ´æ·Å´ÓflashÖĞ¶Á³öµÄÆ÷¼şµØÖ·
  13          
  14          #ifdef LEARN_BY_QUANTITY // ±£´æn¸öÆ÷¼şµØÖ·
  15          /**
  16           * @brief RFÑ§Ï°¹¦ÄÜ£¬5sÄÚ¼ì²âµ½ÓĞ°´¼ü³¤°´£¬Ôò½«Õâ¸öÒ£¿ØÆ÷µÄÆ÷¼şµØÖ·Ğ´Èëµ½flashÖĞ£¨Ò»°ã·ÅÔÚÉÏµçµÄ5sÖĞÊ¹ÓÃ£
             -©
  17           *          Èç¹û my_config.hÎÄ¼şÖĞµÄUSE_RF_UNPAIRÎª1£¬ÄÇÃ´µ±ÊÕµ½ÓĞÓëflashÖĞÏàÍ¬µÄÆ÷¼şµØÖ·´«À´µÄĞÅºÅÊ±£¬
  18           *          »á´ÓflashÖĞÉ¾³ı¸ÃµØÖ·Êı¾İ£¬ÊµÏÖÈ¡ÏûÅä¶Ô
  19           */
  20          void rf_learn(void)
  21          {
  22   1          u32 appear_themost_ele = 0; // RF½ÓÊÕÊı×éÖĞ³öÏÖ×î¶à´ÎÊıµÄÔªËØ
  23   1      
  24   1          u32 i = 0; // Ñ­»·¼ÆÊıÖµ
  25   1          u32 j = 0; // Ñ­»·¼ÆÊıÖµ
  26   1      
  27   1          bit isSpare = 0; // ±êÖ¾Î»£¬flashÖĞÊÇ·ñÓĞ¿ÕÏĞÎ»ÖÃÀ´´æ´¢¿ÕµÄµØÖ·
  28   1      
  29   1          u32 temp = 0;             // ÁÙÊ±±äÁ¿£¬´æ·ÅÁÙÊ±Öµ
  30   1          u32 the_oldest_index = 0; // ×î¾ÉµÄÆ÷¼şµØÖ·¶ÔÓ¦µÄÊı×éÏÂ±ê
  31   1      
  32   1          // ´ò¿ª¶¨Ê±Æ÷
  33   1          tmr2_enable();
  34   1      
  35   1          while (tmr2_flag != 1)
  36   1          {
  37   2              WDT_KEY = WDT_KEY_VAL(0xAA); // Î¹¹·
  38   2              rf_recv_databuf();           // Ã¿´ÎÑ­»·£¬ÊÔ×Å¶ÁÈ¡Ò»´ÎÊı¾İ
  39   2      
  40   2              // Õâ¶ÎÊ±¼äÄÚ£¬Ò»Ö±Çå¿Õ ´¥Ãş°´¼üÄ£¿é³õÊ¼»¯µÄµ¹¼ÆÊ±
  41   2              touch_cnt_down_clear();
  42   2          }
  43   1      
  44   1          // 5sºó£¬¹Ø±Õ¶¨Ê±Æ÷£¬Çå¿ÕËüÓ²¼şµÄ¼ÆÊıÖµ
  45   1          tmr2_disable();
  46   1          tmr2_flag = 0; // Çå³ı±êÖ¾Î»
  47   1          tmr2_cnt = 0;  // Çå³ı¶¨Ê±Æ÷µÄ¼ÆÊıÖµ
  48   1      
  49   1          // ´ÓflashÖĞ¶ÁÈ¡Æ÷¼şµØÖ·
  50   1          flash_read(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
  51   1      
  52   1          // Èç¹ûÕâ¶ÎÊ±¼äÄÚ¼ì²âµ½ÓĞ°´¼ü³¤°´£¬Ê¹µÃ±êÖ¾Î»ÖÃÒ»£¬½øĞĞÏà¹ØµÄ´¦Àí
C51 COMPILER V9.60.7.0   RF_LEARN                                                          07/08/2025 17:28:58 PAGE 2   

  53   1          if (rf_data_buf_overflow)
  54   1          {
  55   2              rf_data_buf_overflow = 0;
  56   2              // ÕÒ³öÊı×éÖĞ³öÏÖ´ÎÊı×î¶àµÄÔªËØ
  57   2              appear_themost(rf_data_buf, sizeof(rf_data_buf) / sizeof(rf_data_buf[0]), &appear_themost_ele, NUL
             -L);
  58   2      
  59   2              // Èç¹û²»ÊÇµçÔ´°´¼ü(Ñ§Ï°°´¼ü)£¬º¯ÊıÍË³ö
  60   2              if (((appear_themost_ele & 0xFF) != 0x01) && ((appear_themost_ele & 0xFF) != 0x03))
  61   2              {
  62   3                  return;
  63   3              }
  64   2      
  65   2              // Èç¹ûÊÇµçÔ´°´¼ü
  66   2              // ½«Æ÷¼şµØÖ·Ğ´Èëµ½µ¥Æ¬»úµÄflashÖĞ
  67   2              // |--Èç¹ûÃ»ÓĞÔòÖ±½ÓĞ´Èë£¬Èç¹ûÓĞÔò¸²¸Ç×î¾ÉµÄÆ÷¼şµØÖ·£¬ÔÙÒ»´ÎĞÔĞ´Èë
  68   2      
  69   2              // Í¨¹ıÑ­»·ÅĞ¶ÏflashÖĞÊÇ·ñÒÑ¾­ÓĞ¶ÔÓ¦µÄµØÖ·
  70   2              for (i = 0; i < ADDR_MAX_NUM; i++)
  71   2              {
  72   3                  if (addr_info.addr_buf[i] == (appear_themost_ele >> 8))
  73   3                  {
  74   4      #if USE_RF_UNPAIR // Èç¹û¿ªÆô È¡ÏûÅä¶Ô
              
                              // ÈôÆ÷¼şµØÖ·ÏàÍ¬£¬Çå³ı¶ÔÓ¦µÄÊı¾İ
                              addr_info.addr_buf[i] = 0;
                              addr_info.weighted_val_buf[i] = 0; // Çå³ıÈ¨Öµ
                              addr_info.remote_type[i] = 0;      // Çå³ıÒ£¿ØÆ÷ÀàĞÍ
              
                              // ½«Æ÷¼şµØÖ·Ğ´»Øflash
                              flash_erase_sector(FLASH_DEVICE_START_ADDR);
                              flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
              
                              return; // Ğ´ÈëÍê³É£¬º¯ÊıÖ±½Ó·µ»Ø
              
              #else // Èç¹ûÃ»ÓĞ¿ªÆô È¡ÏûÅä¶Ô
  88   4      
  89   4                      addr_info.weighted_val_buf[i] = 0;
  90   4                      addr_info.addr_buf[i] = (appear_themost_ele >> 8); // ±£´æµØÖ·ÕâÒ»²½¿ÉÒÔ²»ÓÃ¼Ó£¬ÒòÎª´ËÊ±µØ
             -Ö·ÊÇÏàÍ¬µÄ
  91   4      
  92   4                      if (0x01 == (appear_themost_ele & 0xFF))
  93   4                      {
  94   5                          // Èç¹ûÊÇ´óÒ¡¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
  95   5                          addr_info.remote_type[i] = REMOTE_TYPE_BIG_RM;
  96   5                      }
  97   4                      else if (0x03 == (appear_themost_ele & 0xFF))
  98   4                      {
  99   5                          // Èç¹ûÊÇĞ¡Ò£¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
 100   5                          addr_info.remote_type[i] = REMOTE_TYPE_SMALL_RM;
 101   5                      }
 102   4      
 103   4                      // Ôö¼ÓÆäËûµØÖ·µÄÈ¨Öµ£¨²»Ôö¼Ó¿ÕµÄµØÖ·µÄÈ¨Öµ£©
 104   4                      for (j = 0; j < ADDR_MAX_NUM; j++)
 105   4                      {
 106   5                          if ((j != i) && (addr_info.addr_buf[j] != 0))
 107   5                          {
 108   6                              addr_info.weighted_val_buf[j]++;
 109   6                          }
 110   5                      }
 111   4      
 112   4                      // ×îºó£¬½«Æ÷¼şµØÖ·Ğ´»Øflash
C51 COMPILER V9.60.7.0   RF_LEARN                                                          07/08/2025 17:28:58 PAGE 3   

 113   4                      flash_erase_sector(FLASH_DEVICE_START_ADDR);
 114   4                      flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
 115   4                      return; // ½áÊøÑ§Ï°
 116   4      
 117   4      #endif // end if USE_RF_UNPAIR
 118   4                  }
 119   3              }
 120   2      
 121   2              // Èç¹ûÒª±£´æµÄµØÖ·ÔÚflashÖĞ²¢Ã»ÓĞÖØ¸´
 122   2              // |---ÕÒÒ»´¦¿ÕµÄµØ·½±£´æ£¬Èç¹ûÃ»ÓĞ£¬Ôò¸²¸Ç×î¾ÉµÄÆ÷¼şµØÖ·
 123   2              for (i = 0; i < ADDR_MAX_NUM; i++)
 124   2              {
 125   3                  if ((addr_info.weighted_val_buf[i] == 0) && (addr_info.addr_buf[i] == 0))
 126   3                  {
 127   4                      // Èç¹ûÓĞ¿ÕµÄµØ·½£¬Ö±½Ó±£´æ
 128   4                      addr_info.weighted_val_buf[i] = 0;
 129   4                      addr_info.addr_buf[i] = (appear_themost_ele >> 8);
 130   4      
 131   4                      if (0x01 == (appear_themost_ele & 0xFF))
 132   4                      {
 133   5                          // Èç¹ûÊÇ´óÒ¡¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
 134   5                          addr_info.remote_type[i] = REMOTE_TYPE_BIG_RM;
 135   5                      }
 136   4                      else if (0x03 == (appear_themost_ele & 0xFF))
 137   4                      {
 138   5                          // Èç¹ûÊÇĞ¡Ò£¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
 139   5                          addr_info.remote_type[i] = REMOTE_TYPE_SMALL_RM;
 140   5                      }
 141   4      
 142   4                      // Ôö¼ÓÆäËûµØÖ·µÄÈ¨Öµ£¨²»Ôö¼Ó¿ÕµÄµØÖ·µÄÈ¨Öµ£©
 143   4                      for (j = 0; j < ADDR_MAX_NUM; j++)
 144   4                      {
 145   5                          if ((j != i) && (addr_info.addr_buf[j] != 0))
 146   5                          {
 147   6                              addr_info.weighted_val_buf[j]++;
 148   6                          }
 149   5                      }
 150   4      
 151   4                      isSpare = 1;
 152   4                      break;
 153   4                  }
 154   3              }
 155   2      
 156   2              // Èç¹ûÃ»ÓĞ¿ÕÓàµÄµØ·½£¬Ôò¸²¸Ç×î¾ÉµÄÆ÷¼şµØÖ·
 157   2              if (0 == isSpare)
 158   2              {
 159   3                  // Í¨¹ıÑ­»·ÕÒµ½×î¾ÉµÄµØÖ·ËùÔÚµÄÊı×éÏÂ±ê
 160   3                  for (i = 0; i < ADDR_MAX_NUM; i++)
 161   3                  {
 162   4                      if (addr_info.weighted_val_buf[i] > temp)
 163   4                      {
 164   5                          temp = addr_info.weighted_val_buf[i];
 165   5                          the_oldest_index = i;
 166   5                      }
 167   4                  }
 168   3      
 169   3                  addr_info.addr_buf[the_oldest_index] = (appear_themost_ele >> 8); // ±£´æÆ÷¼şµØÖ·
 170   3                  addr_info.weighted_val_buf[the_oldest_index] = 0;                 // È¨ÖµÉèÖÃÎª0
 171   3      
 172   3                  if (0x01 == (appear_themost_ele & 0xFF))
 173   3                  {
 174   4                      // Èç¹ûÊÇ´óÒ¡¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
C51 COMPILER V9.60.7.0   RF_LEARN                                                          07/08/2025 17:28:58 PAGE 4   

 175   4                      addr_info.remote_type[the_oldest_index] = REMOTE_TYPE_BIG_RM;
 176   4                  }
 177   3                  else if (0x03 == (appear_themost_ele & 0xFF))
 178   3                  {
 179   4                      // Èç¹ûÊÇĞ¡Ò£¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
 180   4                      addr_info.remote_type[the_oldest_index] = REMOTE_TYPE_SMALL_RM;
 181   4                  }
 182   3      
 183   3                  // Ôö¼ÓÆäËûµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£¨ÕâÀïÒª¿¼ÂÇ²»Ôö¼Ó¿ÕµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£©
 184   3                  for (j = 0; j < ADDR_MAX_NUM; j++)
 185   3                  {
 186   4                      if ((j != the_oldest_index) && (addr_info.addr_buf[j] != 0))
 187   4                      {
 188   5                          addr_info.weighted_val_buf[j]++;
 189   5                      }
 190   4                  }
 191   3              }
 192   2      
 193   2              // ×îºó£¬½«Æ÷¼şµØÖ·Ğ´»Øflash
 194   2              flash_erase_sector(FLASH_DEVICE_START_ADDR);
 195   2              flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
 196   2          }
 197   1      }
 198          
 199          // ÅĞ¶Ïµ±Ç°½ÓÊÕµÄÊı¾İµÄµØÖ·ÊÇ·ñÓëflashÖĞ±£´æµÄµØÖ·Æ¥Åä
 200          // ĞèÒªÏÈÑ§Ï°£¬´ÓflashÖĞ¶Á³öÊı¾İ
 201          // ·µ»Ø£º 0--²»Æ¥Åä£¬1--Æ¥Åä
 202          u8 rf_addr_isMatch(void)
 203          {
 204   1          u8 i = 0;
 205   1          for (i = 0; i < ADDR_MAX_NUM; i++)
 206   1          {
 207   2              if (addr_info.addr_buf[i] == (rf_data >> 8))
 208   2              {
 209   3                  return 1;
 210   3              }
 211   2          }
 212   1      
 213   1          return 0;
 214   1      }
 215          
 216          // ²âÊÔº¯Êı£¬²é¿´flashÖĞ°´²»Í¬µØÖ·À´±£´æµÄËùÓĞÆ÷¼şµØÖ·
 217          void show_addr_info_save_by_nums(void)
 218          {
 219   1          u32 i;
 220   1      
 221   1          for (i = 0; i < ADDR_MAX_NUM; i++)
 222   1          {
 223   2              send_keyval(addr_info.weighted_val_buf[i]);
 224   2              send_keyval(addr_info.addr_buf[i]);
 225   2          }
 226   1      }
 227          
 228          #endif // end of #ifdef LEARN_BY_QUANTITY
 229          
 230          #ifdef LEARN_BY_TYPE
              /**
               * @brief RFÑ§Ï°¹¦ÄÜ£¬5sÄÚ¼ì²âµ½ÓĞ°´¼ü³¤°´£¬Ôò½«Õâ¸öÒ£¿ØÆ÷µÄÆ÷¼şµØÖ·Ğ´Èëµ½flashÖĞ£¨Ò»°ã·ÅÔÚÉÏµçµÄ5sÖĞÊ¹ÓÃ£
             -©
               *          Èç¹û my_config.hÎÄ¼şÖĞµÄUSE_RF_UNPAIRÎª1£¬ÄÇÃ´µ±ÊÕµ½ÓĞÓëflashÖĞÏàÍ¬µÄÆ÷¼şµØÖ·´«À´µÄĞÅºÅÊ±£¬
               *          »á´ÓflashÖĞÉ¾³ı¸ÃµØÖ·Êı¾İ£¬ÊµÏÖÈ¡ÏûÅä¶Ô
               */
C51 COMPILER V9.60.7.0   RF_LEARN                                                          07/08/2025 17:28:58 PAGE 5   

              void rf_learn(void)
              {
                  u32 appear_themost_ele = 0; // RF½ÓÊÕÊı×éÖĞ³öÏÖ×î¶à´ÎÊıµÄÔªËØ
              
                  int32 i = 0; // Ñ­»·¼ÆÊıÖµ
                  int32 j = 0; // Ñ­»·¼ÆÊıÖµ
              
                  u8 isExist = 0; // ±êÖ¾Î»£¬µØÖ·ÊÇ·ñÒÑ¾­ÔÚflash±£´æ
                  u8 isSpare = 0; // ±êÖ¾Î»£¬±êÖ¾´æ·ÅµØÖ·µÄÈİÆ÷ÖĞÊÇ·ñÓĞ¿ÕµÄµØ·½
              
                  u32 temp = 0;             // ´æ·ÅÁÙÊ±Öµ
                  u32 the_oldest_index = 0; // ×î¾ÉµÄÆ÷¼şµØÖ·¶ÔÓ¦µÄÊı×éÏÂ±ê
              
                  // ´ò¿ª¶¨Ê±Æ÷
                  tmr2_enable();
              
                  while (tmr2_flag != 1)
                  {
                      WDT_KEY = WDT_KEY_VAL(0xAA); // Î¹¹·
                      rf_recv_databuf();           // Ã¿´ÎÑ­»·£¬ÊÔ×Å¶ÁÈ¡Ò»´ÎÊı¾İ
                  }
              
                  // 5sºó£¬¹Ø±Õ¶¨Ê±Æ÷£¬Çå¿ÕËüÓ²¼şµÄ¼ÆÊıÖµ
                  tmr2_disable();
                  tmr2_flag = 0; // Çå³ı±êÖ¾Î»
                  tmr2_cnt = 0;  // Çå³ı¶¨Ê±Æ÷µÄ¼ÆÊıÖµ
              
                  // ´ÓflashÖĞ¶ÁÈ¡Æ÷¼şµØÖ·
                  flash_read(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
              
                  // Èç¹ûÕâ¶ÎÊ±¼äÄÚ£¨5sÄÚ£©¼ì²âµ½ÓĞ°´¼ü³¤°´£¬Ê¹µÃ±êÖ¾Î»ÖÃÒ»£¬½øĞĞÏà¹ØµÄ´¦Àí
                  if (rf_data_buf_overflow)
                  {
                      rf_data_buf_overflow = 0;
                      // ÕÒ³öÊı×éÖĞ³öÏÖ´ÎÊı×î¶àµÄÔªËØ
                      appear_themost(rf_data_buf, sizeof(rf_data_buf) / sizeof(rf_data_buf[0]), &appear_themost_ele, NUL
             -L);
              
                      // Èç¹û²»ÊÇµçÔ´°´¼ü£¬º¯ÊıÍË³ö£¨´ı²¹³ä£©
              
                      // Èç¹ûÊÇµçÔ´°´¼ü
                      // ½«Æ÷¼şµØÖ·Ğ´Èëµ½µ¥Æ¬»úµÄflashÖĞ
                      // |--Èç¹ûÃ»ÓĞÔòÖ±½ÓĞ´Èë£¬Èç¹ûÓĞÔò¸²¸Ç×î¾ÉµÄÆ÷¼şµØÖ·£¬ÔÙÒ»´ÎĞÔĞ´Èë
                      for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                      {
                          if (addr_info.type_buf[i] == (appear_themost_ele & 0xFF))
                          {
                              // Èç¹ûflashÖĞÒÑ¾­ÓĞ¶ÔÓ¦ÀàĞÍµÄÆ÷¼şµØÖ·
                              isExist = 1;
                              break;
                          }
                      }
              
                      if (isExist)
                      {
                          // Èç¹ûflashÖĞÒÑ¾­ÓĞ¶ÔÓ¦ÀàĞÍµÄÆ÷¼şµØÖ·
                          // ÅĞ¶ÏÆ÷¼şµØÖ·ÊÇ·ñÏàÍ¬
                          if (addr_info.addr_buf[i] == (appear_themost_ele >> 8))
                          {
              #if USE_RF_UNPAIR // Èç¹ûÊ¹ÓÃÁËÈ¡ÏûÅä¶Ô
              
                              // ÈôÆ÷¼şµØÖ·ÏàÍ¬£¬Çå³ı¶ÔÓ¦µÄÊı¾İ
C51 COMPILER V9.60.7.0   RF_LEARN                                                          07/08/2025 17:28:58 PAGE 6   

                              addr_info.addr_buf[i] = 0;
                              addr_info.type_buf[i] = 0;
                              addr_info.weighted_val_buf[i] = 0;
              
                              // ½«Æ÷¼şµØÖ·Ğ´»Øflash
                              flash_erase_sector(FLASH_DEVICE_START_ADDR);
                              flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
              
                              return; // Ğ´ÈëÍê³Éºó£¬º¯Êı¿ÉÒÔÖ±½Ó·µ»ØÁË
              
              #else // Èç¹û²»Ê¹ÓÃÈ¡ÏûÅä¶Ô
              
                              // ÈôÆ÷¼şµØÖ·ÏàÍ¬Ôò²»ÓÃ¸²¸Ç£¬Ö±½ÓÍË³ö
                              return;
              
              #endif // end if USE_RF_UNPAIR
                          }
              
                          addr_info.addr_buf[i] = (appear_themost_ele >> 8); // ¸²¸ÇÆ÷¼şµØÖ·
                          addr_info.weighted_val_buf[i] = 0;                 // È¨ÖµÉèÖÃÎª0£¬±íÊ¾ËüÊÇ×îĞÂĞ´ÈëµÄ
              
                          // Ôö¼ÓÆäËûÀàĞÍµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£¨ÕâÀïÒª¿¼ÂÇ²»Ôö¼Ó¿ÕµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£©
                          for (j = 0; j < ADDR_MAX_TYPE_NUM; j++)
                          {
                              if ((j != i) && (addr_info.addr_buf[j] != 0))
                              {
                                  addr_info.weighted_val_buf[j]++;
                              }
                          }
                      }
                      else
                      {
                          // Èç¹ûflashÖĞÃ»ÓĞ¶ÔÓ¦ÀàĞÍµÄÆ÷¼şµØÖ·£¬ÔòÕÒÒ»´¦¿ÕµÄµØ·½£¬±£´æ
                          // Èç¹ûÃ»ÓĞ¿ÕµÄµØ·½£¬¸²¸Ç×î¾ÉµÄÀàĞÍºÍÆ÷¼şµØÖ·
              
                          for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                          {
                              if ((addr_info.type_buf[i] == 0) && (addr_info.addr_buf[i] == 0) && (addr_info.weighted_va
             -l_buf[i] == 0))
                              {
                                  // Èç¹ûÓĞ¿ÕµÄµØ·½
                                  addr_info.type_buf[i] = (appear_themost_ele & 0xFF); // ¼üÖµ×÷ÎªÆ÷¼şÀàĞÍ£¬±£´æÆğÀ´
                                  addr_info.addr_buf[i] = (appear_themost_ele >> 8);   // ±£´æÆ÷¼şµØÖ·
                                  addr_info.weighted_val_buf[i] = 0;                   // È¨ÖµÉèÖÃÎª0£¬±íÊ¾ËüÊÇ×îĞÂĞ´Èëµ
             -Ä
              
                                  // Ôö¼ÓÆäËûÀàĞÍµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£¨ÕâÀïÒª¿¼ÂÇ²»Ôö¼Ó¿ÕµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£©
                                  for (j = 0; j < ADDR_MAX_TYPE_NUM; j++)
                                  {
                                      if ((j != i) && (addr_info.addr_buf[j] != 0))
                                      {
                                          addr_info.weighted_val_buf[j]++;
                                      }
                                  }
                                  isSpare = 1; // ÓĞ¿ÕÓàµÄµØ·½£¬²¢ÇÒÒÑ¾­Íê³É±£´æ
                                  break;
                              }
                          }
              
                          // Èç¹ûÃ»ÓĞ¿ÕÓàµÄµØ·½£¬Ôò¸²¸Ç×î¾ÉµÄÀàĞÍºÍÆ÷¼şµØÖ·
                          if (0 == isSpare)
                          {
C51 COMPILER V9.60.7.0   RF_LEARN                                                          07/08/2025 17:28:58 PAGE 7   

                              // Í¨¹ıÑ­»·ÕÒµ½×î¾ÉµÄÀàĞÍËùÔÚµÄÊı×éÏÂ±ê
                              for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                              {
                                  if (addr_info.weighted_val_buf[i] > temp)
                                  {
                                      temp = addr_info.weighted_val_buf[i];
                                      the_oldest_index = i;
                                  }
                              }
              
                              addr_info.type_buf[the_oldest_index] = (appear_themost_ele & 0xFF); // ¼üÖµ×÷ÎªÆ÷¼şÀàĞÍ
                              addr_info.addr_buf[the_oldest_index] = (appear_themost_ele >> 8);   // ±£´æÆ÷¼şµØÖ·
                              addr_info.weighted_val_buf[the_oldest_index] = 0;
              
                              // Ôö¼ÓÆäËûÀàĞÍµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£¨ÕâÀïÒª¿¼ÂÇ²»Ôö¼Ó¿ÕµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£©
                              for (j = 0; j < ADDR_MAX_TYPE_NUM; j++)
                              {
                                  if ((j != the_oldest_index) && (addr_info.addr_buf[j] != 0))
                                  {
                                      addr_info.weighted_val_buf[j]++;
                                  }
                              }
                          }
                      }
              
                      // ½«Æ÷¼şµØÖ·Ğ´»Øflash
                      flash_erase_sector(FLASH_DEVICE_START_ADDR);
                      flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
                  }
              }
              
              // ÅĞ¶Ïµ±Ç°½ÓÊÕµÄÊı¾İµÄµØÖ·ÊÇ·ñÓëflashÖĞ±£´æµÄµØÖ·Æ¥Åä
              // ĞèÒªÏÈÑ§Ï°£¬´ÓflashÖĞ¶Á³öÊı¾İ
              // ·µ»Ø£º 0--²»Æ¥Åä£¬1--Æ¥Åä
              u8 rf_addr_isMatch(void)
              {
                  u32 i = 0;
                  for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                  {
                      if (addr_info.addr_buf[i] == (rf_data >> 8))
                      {
                          return 1;
                      }
                  }
              
                  return 0;
              }
              
              // ²âÊÔº¯Êı£¬²é¿´flashÖĞ°´Æ÷¼şÀàĞÍÀ´±£´æµÄÆ÷¼şµØÖ·
              void show_addr_info_save_by_type(void)
              {
                  u32 i;
              
                  for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                  {
                      send_keyval(addr_info.weighted_val_buf[i]);
                      send_keyval(addr_info.type_buf[i]);
                      send_keyval(addr_info.addr_buf[i]);
                  }
              }
              
              #endif // end ifdef LEARN_BY_TYPE
C51 COMPILER V9.60.7.0   RF_LEARN                                                          07/08/2025 17:28:58 PAGE 8   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1027    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     12      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
