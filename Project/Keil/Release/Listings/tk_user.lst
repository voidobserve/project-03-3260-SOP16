C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TK_USER
OBJECT MODULE PLACED IN .\Release\Objects\tk_user.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\tk_user.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\tk_user.l
                    -st) OBJECT(.\Release\Objects\tk_user.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    User/tk_user.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    05-20-2022
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2022 TAIXIN-IC</center></h2>
  12           *
  13           *
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          /* Includes ------------------------------------------------------------------*/
  19          #include "include.h"
  20          #include "my_gpio.h"  // 自定义的、使用到的引脚
  21          #include "rf_recv.h"  // RF315解码和RF接收引脚相关的函数
  22          #include "send_key.h" // 发送键值的引脚和相关函数
  23          
  24          #include "rf_learn.h" // rf学习相关的函数
  25          
  26          #include "tmr2.h"
  27          #include "tmr3.h"
  28          #include "rf_scan.h" // 包含了长短按信息的定义
  29          
  30          #include "key_conversion.h" // 包含了触摸按键对应的键值
  31          
  32          // #include "stimer0.h"
  33          #include "timer0.h"
  34          
  35          /** @addtogroup Template_Project
  36           * @{
  37           */
  38          
  39          /* Private typedef -----------------------------------------------------------*/
  40          /* Private define ------------------------------------------------------------*/
  41          /* Private macro -------------------------------------------------------------*/
  42          /* Private variables ---------------------------------------------------------*/
  43          /* Private function prototypes -----------------------------------------------*/
  44          /* Private functions ---------------------------------------------------------*/
  45          
  46          /**
  47           * @brief  Touchkey  debug uart init function
  48           * @param  None
  49           * @retval None
  50           */
  51          xdata u16 led_data[1];                           // LED显示buff
  52          #define LED_DIS_FREQ (1000000 / 16 / 8 / 60 - 1) // 一个CON的显示时间60Hz    60-1=1M/(LED_COMCON*16*LED_TI
             -ME_CON)
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 2   

  53          
  54          unsigned int xdata display_data = 0;
  55          
  56          /**
  57           * @brief  调试接口IO初始化函数.
  58           * @param  None
  59           * @retval None
  60           */
  61          #if TK_DEBUG_EN
              void debug_gpio_config(void)
              {
              #if 1
                  P2_MD0 &= ~GPIO_P21_MODE_SEL(0x03);
                  P2_MD0 |= GPIO_P21_MODE_SEL(0x01);
                  FOUT_S21 = GPIO_FOUT_UART1_TX;
              #else
                  P2_MD1 &= ~GPIO_P27_MODE_SEL(0x03);
                  P2_MD1 |= GPIO_P27_MODE_SEL(0x01);
                  FOUT_S27 = GPIO_FOUT_UART1_TX;
              #endif
              }
              #endif
  75          
  76          #if 0
              /**
               * @brief  LED INIT FUNCTION
               * @param  None
               * @retval None
               */
              // 在开发板上：
              // P2_7连接到四个蓝色LED的负极的公共端
              // P0_3连接到LED1正极
              // P3_0连接到LED2正极
              // P1_0连接到LED3正极
              // P0_7连接到LED4正极
              void led_init(void)
              {
                  // 配置COM0   P27为输出模式
                  // P2_MD1，P2的工作模式寄存器1
                  P2_MD1 &= ~GPIO_P27_MODE_SEL(0x3); // 清零P2_MD1寄存器的6-7位
                  P2_MD1 |= GPIO_P27_MODE_SEL(0x1);  // P2_MD1的6~7位设置为0x01，这样会将P2的第7个IO设置为输出模式
              
                  // 配置IO的驱动能力
                  // P2的第7个IO的驱动电流为8mA
                  P2_DRV7 = GPIO_P27_DRV_SEL(0x1);
              
                  // 配置SEG0-SEG4 P03\P30\P10\P07-输出模式
                  // P0_3、P3_0、P1_0和P0_1配置为输出模式
                  // 下面是先清零，再置位的操作
                  P0_MD0 &= ~GPIO_P03_MODE_SEL(0x3);
                  P3_MD0 &= ~GPIO_P30_MODE_SEL(0x3);
                  P1_MD0 &= ~GPIO_P10_MODE_SEL(0x3);
                  P0_MD1 &= ~GPIO_P07_MODE_SEL(0x3);
              
                  P0_MD0 |= GPIO_P03_MODE_SEL(0x1);
                  P3_MD0 |= GPIO_P30_MODE_SEL(0x1);
                  P1_MD0 |= GPIO_P10_MODE_SEL(0x1);
                  P0_MD1 |= GPIO_P07_MODE_SEL(0x1);
              
                  // SEG0-SEG4 P03\P30\P10\P07
                  // 配置P0_3、P3_0、P1_0和P0_1的输出功能，驱动LED（应该是连接到了片上外设LED模块，这个模块是个控制器）
                  FOUT_S03 = GPIO_FOUT_LED_SEG0;
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 3   

                  FOUT_S30 = GPIO_FOUT_LED_SEG1;
                  FOUT_S10 = GPIO_FOUT_LED_SEG2;
                  FOUT_S07 = GPIO_FOUT_LED_SEG3;
              
                  // 配置P0_3、P3_0、P1_0和P0_1的输出电流，8mA
                  P0_DRV3 = GPIO_P03_DRV_SEL(0x1);
                  P3_DRV0 = GPIO_P30_DRV_SEL(0x1);
                  P1_DRV0 = GPIO_P10_DRV_SEL(0x1);
                  P0_DRV7 = GPIO_P07_DRV_SEL(0x1);
              
                  // COM0 P27
                  // 配置P2_7的输出功能，连接到LED的公共端0
                  FOUT_S27 = GPIO_FOUT_LED_COM0;
              
                  CLK_CON2 |= CLK_LED_EN(0x1); // 打开LED模块的时钟（打开片上外设LED模块的时钟）
              
                  // 0x55表示允许访问和设置 wdt_psr（在WDT_CON中，psr表示看门狗定时时间）
                  WDT_KEY = 0x55;                // 操作IO_MAP寄存器需要写KEY
                  IO_MAP |= MAP_LED_DMA_EN(0x1); // LED DMA使能
                  WDT_KEY = 0xBB;                // 写入一个错误的数值，恢复该寄存器的写保护
              
                  // 打开LED模块的时钟
                  CLK_CON2 |= 0x10;
              
                  LED_SEGCONL = LED_SEG0_EN(0x1) | // SEG0 使能
                                LED_SEG1_EN(0x1) | // SEG0 使能
                                LED_SEG2_EN(0x1) | // SEG0 使能
                                LED_SEG3_EN(0x1);  // SEG0 使能
                  LED_COMCON = LED_COM0_EN(0x1);   // COM1 使能
              
                  LED_DMAADRH = LED_DMA_ADDR_H((((u16)led_data) >> 8) & 0xFF); // LED数据储存首地址的高8位
                  LED_DMAADRL = LED_DMA_ADDR_L((((u16)led_data) >> 0) & 0xFF); // LED数据储存首地址的低8位
                  LED_TIMECON = LED_SCAN_TIME(LED_DIS_FREQ);                   // 扫描到某个com或seg时点亮的时间,步长为3
             -2微秒
                  LED_CON = LED_COM_SEG_SEL(0x0) |                             // 扫描方式选择com扫描
                            LED_EN(0x1);                                       // LED使能,使能之后从DMAADDRH和DMAADDRL的
             -地址开始拿数据扫描点亮,用户将数据写到对应的地址即可
              
                  led_data[0] = 0x00000f00; // 一开始让四个LED全部点亮
                  // led_data[0] = 0x00000000; // 一开始让四个LED全部熄灭
              }
              #endif
 155          
 156          #if USE_MY_DEBUG
              extern void uart1_config(void);
              #endif // #if USE_MY_DEBUG
 159          
 160          // /**
 161          //  * @brief  用户代码初始化函数接口.
 162          //  * @param  None
 163          //  * @retval None
 164          //  */
 165          // void user_init(void)
 166          // {
 167          //     // led_init(); // 初始化LED相关的引脚
 168          
 169          //     timer0_config();
 170          //     rfin_init(); // RF315接收引脚初始化，这里也初始化了tmr0
 171          
 172          //     // p12_output_config(); // 测试用，P12初始化，配置为输出模式
 173          
 174          //     send_keyval_pin_init();   // 初始化键值的发送引脚
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 4   

 175          //     send_keyval_timer_init(); // 初始化发送键值的引脚所使用到的定时器，定时器默认关闭
 176          
 177          //     // tmr0_enable(); // 打开采集RF信号的定时器
 178          //     // tmr1_enable(); // 打开发送键值的引脚所使用到的定时器，测试用，看看定时器中断是否按配置的时间触发
 179          
 180          //     tmr2_config(); // 上电5s内的"学习"所使用的定时器
 181          //     tmr3_config(); // 配置定时器，每10ms产生一次中断，对应的计数值+1，用来判断按键的短按、长按和持续
 182          //     tmr4_config(); // 打开识别遥控器双击所需要的定时器
 183          
 184          //     // stimer0_config(); // 1ms定时器
 185          
 186          //     // p01_output_config(); // 开发板LED6对应的引脚初始化
 187          //     // p26_output_config(); // 开发板LED7对应的引脚初始化
 188          
 189          // #if USE_MY_DEBUG
 190          //     uart1_config();
 191          // #endif //     #if USE_MY_DEBUG
 192          // }
 193          
 194          // void led_display(void)
 195          // {
 196          // led_data[0] = display_data;
 197          // }
 198          
 199          #ifdef DEVELOPMENT_BOARD // 开发板上对应额触摸按键函数接口
              /**
               * @brief  用户代码循环执行函数接口.（触摸按键扫描函数接口）
               * @param  None
               * @retval None
               */
              void user_handle(void)
              {
                  volatile unsigned long int KeyOnOutput = __tk_key_flag; // __tk_key_flag单次按键标志
              
                  static volatile unsigned long int KeyOld = 0; // 用于存放长按时，对应的按键
              
                  // 是否长按的标志，0--否，1--是
                  // 需要保存长按的状态，表示定时器一直在发送键值
                  static unsigned char long_touch_flag = 0; // 上一次扫描到的按键是否为长按的标志
              
                  static volatile u32 cnt = 0; // 长按计数值
              
                  u32 i = 0; // 循环计数值
              
                  u16 send_data = 0; // 要发送的带有键值的数据
              
                  if (KeyOnOutput && 0 == long_touch_flag && cnt < TK_LONG_KEY_TIME) // 如果有按键按下（并且之前扫描到的
             -不是长按）
                  {
                      // 通过循环判断是否为长按
                      for (i = 0; i < 500000; i++) // 实际上用不到这么大的数字，到了设定的长按时间就会退出
                      {
                          // 按键扫描函数，使用了库里面的接口（闭源库）
                          // 这个函数会更新__tk_key_flag的值
                          delay_ms(10);
                          __tk_scan();
              
                          if (KeyOnOutput == __tk_key_flag)
                          {
                              // 如果按键键值一致，说明按键一直被按下，未松开
                              cnt++;
                          }
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 5   

                          else
                          {
                              // 如果按键键值不一致或是松开了按键
                              // cnt = 0;
                              break;
                          }
                          if (cnt > TK_LONG_KEY_TIME) // 如果长按超过了这里设置的时间
                          {
                              long_touch_flag = 1; // 标记为长按
                              break;
                          }
                      }
              
                      if (cnt > TK_LONG_KEY_TIME)
                      {
                          long_touch_flag = 1; // 标记为长按
                      }
                      else
                      {
                          // 如果是短按
                          cnt = 0; // 清除长按的计数值
              
                          // 判断当前触摸的键值，做对应的操作
                          if (TK_CH0_VALIB == KeyOnOutput)
                          {
                              // 如果开发板的TK1被触摸
                              display_data ^= 0x0100; // 对应的LED状态取反，后面会调用led_display()刷新
                              for (i = 0; i < 300; i++)
                              {
                                  delay_ms(1);
                                  __tk_scan();
                                  KeyOnOutput = __tk_key_flag;
              
                                  if (TK_CH0_VALIB == KeyOnOutput)
                                  {
                                      // 如果检测到是同一个按键按下，说明是双击
                                      // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
                                      while (0 != KeyOnOutput)
                                      {
                                          __tk_scan();
                                          KeyOnOutput = __tk_key_flag;
                                      }
              
                                      send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK1);
                                      return;
                                  }
                              }
              
                              // 如果不是同一个按键按下或是没有值，说明是短按
                              send_status_keyval(KEY_PRESS_SHORT, KEY_TK1); // 发送带有状态的键值
                          }
                          else if (TK_CH4_VALIB == KeyOnOutput)
                          {
                              // 如果开发板的TK2被触摸
                              display_data ^= 0x0200; // 对应的LED状态取反，后面会调用led_display()刷新
                              for (i = 0; i < 300; i++)
                              {
                                  delay_ms(1);
                                  __tk_scan();
                                  KeyOnOutput = __tk_key_flag;
              
                                  if (TK_CH4_VALIB == KeyOnOutput)
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 6   

                                  {
                                      // 如果检测到是同一个按键按下，说明是双击
                                      // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
                                      while (0 != KeyOnOutput)
                                      {
                                          __tk_scan();
                                          KeyOnOutput = __tk_key_flag;
                                      }
              
                                      send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK2);
                                      return;
                                  }
                              }
              
                              // 如果不是同一个按键按下或是没有值，说明是短按
                              send_status_keyval(KEY_PRESS_SHORT, KEY_TK2); // 发送带有状态的键值
                          }
                          else if (TK_CH5_VALIB == KeyOnOutput)
                          {
                              // 如果开发板的TK3被触摸
                              display_data ^= 0x0400; // 对应的LED状态取反，后面会调用led_display()刷新
                              for (i = 0; i < 300; i++)
                              {
                                  delay_ms(1);
                                  __tk_scan();
                                  KeyOnOutput = __tk_key_flag;
              
                                  if (TK_CH5_VALIB == KeyOnOutput)
                                  {
                                      // 如果检测到是同一个按键按下，说明是双击
                                      // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
                                      while (0 != KeyOnOutput)
                                      {
                                          __tk_scan();
                                          KeyOnOutput = __tk_key_flag;
                                      }
              
                                      send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK3);
                                      return;
                                  }
                              }
              
                              // 如果不是同一个按键按下或是没有值，说明是短按
                              send_status_keyval(KEY_PRESS_SHORT, KEY_TK3); // 发送带有状态的键值
                          }
                          else if (TK_CH6_VALIB == KeyOnOutput)
                          {
                              // 如果开发板的TK4被触摸
                              display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
                              for (i = 0; i < 300; i++)
                              {
                                  delay_ms(1);
                                  __tk_scan();
                                  KeyOnOutput = __tk_key_flag;
              
                                  if (TK_CH6_VALIB == KeyOnOutput)
                                  {
                                      // 如果检测到是同一个按键按下，说明是双击
                                      // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
                                      while (0 != KeyOnOutput)
                                      {
                                          __tk_scan();
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 7   

                                          KeyOnOutput = __tk_key_flag;
                                      }
              
                                      send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK4);
                                      return;
                                  }
                              }
              
                              // 如果不是同一个按键按下或是没有值，说明是短按
                              send_status_keyval(KEY_PRESS_SHORT, KEY_TK4); // 发送带有状态的键值
                          }
                      }
                  }
              
                  if (1 == long_touch_flag && 0 != KeyOnOutput)
                  {
                      KeyOld = KeyOnOutput;
              
                      // 如果之前是长按，现在还未松开
                      // 判断当前触摸的键值，做对应的操作
                      if (TK_CH0_VALIB == KeyOnOutput)
                      {
                          // 如果开发板的TK1被触摸
                          if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
                          {
                              display_data ^= 0x0100; // 对应的LED状态取反，后面会调用led_display()刷新
                              led_display();          // LED状态更新显示
                              send_status_keyval(KEY_PRESS_LONG, KEY_TK1);
                          }
              
                          // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
                          while (0 != KeyOnOutput)
                          {
                              delay_ms(10);
                              cnt++;
                              __tk_scan();
                              KeyOnOutput = __tk_key_flag;
              
                              if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
                              {
                                  cnt = TK_LONG_KEY_TIME;
                                  send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK1);
                              }
                          }
              
                          // display_data ^= 0x0100; // 对应的LED状态取反，后面会调用led_display()刷新
                          // led_display();          // LED状态更新显示
                      }
                      else if (TK_CH4_VALIB == KeyOnOutput)
                      {
                          // 如果开发板的TK2被触摸
                          if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
                          {
                              display_data ^= 0x0200; // 对应的LED状态取反，后面会调用led_display()刷新
                              led_display();          // LED状态更新显示
                              send_status_keyval(KEY_PRESS_LONG, KEY_TK2);
                          }
              
                          // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
                          while (0 != KeyOnOutput)
                          {
                              delay_ms(10);
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 8   

                              cnt++;
                              __tk_scan();
                              KeyOnOutput = __tk_key_flag;
              
                              if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
                              {
                                  cnt = TK_LONG_KEY_TIME;
                                  send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK2);
                              }
                          }
              
                          // display_data ^= 0x0200; // 对应的LED状态取反，后面会调用led_display()刷新
                          // led_display();          // LED状态更新显示
                      }
                      else if (TK_CH5_VALIB == KeyOnOutput)
                      {
                          // 如果开发板的TK3被触摸
                          if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
                          {
                              display_data ^= 0x0400; // 对应的LED状态取反，后面会调用led_display()刷新
                              led_display();          // LED状态更新显示
                              send_status_keyval(KEY_PRESS_LONG, KEY_TK3);
                          }
              
                          // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
                          while (0 != KeyOnOutput)
                          {
                              delay_ms(10);
                              cnt++;
                              __tk_scan();
                              KeyOnOutput = __tk_key_flag;
              
                              if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
                              {
                                  cnt = TK_LONG_KEY_TIME;
                                  send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK3);
                              }
                          }
              
                          // display_data ^= 0x0400; // 对应的LED状态取反，后面会调用led_display()刷新
                          // led_display();          // LED状态更新显示
                      }
                      else if (TK_CH6_VALIB == KeyOnOutput)
                      {
                          // 如果开发板的TK4被触摸
                          if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
                          {
                              display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
                              led_display();          // LED状态更新显示
                              send_status_keyval(KEY_PRESS_LONG, KEY_TK4);
                          }
              
                          // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
                          while (0 != KeyOnOutput)
                          {
                              delay_ms(10);
                              cnt++;
                              __tk_scan();
                              KeyOnOutput = __tk_key_flag;
              
                              if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
                              {
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 9   

                                  cnt = TK_LONG_KEY_TIME;
                                  send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK4);
                              }
                          }
              
                          // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
                          // led_display();          // LED状态更新显示
                      }
                  }
                  else if (1 == long_touch_flag && 0 == KeyOnOutput)
                  {
                      // 如果之前是长按，现在却松开了按键
                      switch (KeyOld)
                      {
                      case TK_CH0_VALIB:
                          send_status_keyval(KEY_PRESS_LOOSE, KEY_TK1);
                          break;
              
                      case TK_CH4_VALIB:
                          send_status_keyval(KEY_PRESS_LOOSE, KEY_TK2);
                          break;
              
                      case TK_CH5_VALIB:
                          send_status_keyval(KEY_PRESS_LOOSE, KEY_TK3);
                          break;
              
                      case TK_CH6_VALIB:
                          send_status_keyval(KEY_PRESS_LOOSE, KEY_TK4);
                          break;
                      }
              
                      long_touch_flag = 0; // 清除标志位
                      cnt = 0;
                      KeyOld = 0;
                  }
              
              #if 0
                  if (1 == __tk_long_key_flag) // 如果长按按键（这个功能测试发现不行，不能用）
                  {
                      __tk_long_key_flag = 0;
              
                      // 这里可以自己处理，添加自己需要的功能
              
                      P11 = 0;
                  }
              #endif
              
                  led_display(); // LED状态更新显示
              }
              #endif // end ifdef DEVELOPMENT_BOARD
 534          
 535          #ifdef CIRCUIT_BOARD // 目标电路板对应的触摸按键函数接口
 536          /**
 537           * @brief  用户代码循环执行函数接口.（触摸按键扫描函数接口）
 538           * @param  None
 539           * @retval None
 540           */
 541          
 542          #define send_sp (100)
 543          void user_handle(void)
 544          {
 545   1          volatile unsigned long int KeyOnOutput = __tk_key_flag; // __tk_key_flag单次按键标志
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 10  

 546   1      
 547   1          static volatile unsigned long int KeyOld = 0; // 用于存放长按时，对应的按键
 548   1      
 549   1          // 是否长按的标志，0--否，1--是
 550   1          // 需要保存长按的状态，表示定时器一直在发送键值
 551   1          static unsigned char long_touch_flag = 0; // 上一次扫描到的按键是否为长按的标志
 552   1      
 553   1          static volatile u32 cnt = 0; // 长按计数值
 554   1      
 555   1          u32 i = 0; // 循环计数值
 556   1      
 557   1          u16 send_data = 0; // 要发送的带有键值的数据
 558   1      
 559   1          if (0 != __tk_key_flag)
 560   1          {
 561   2              // 有按键按下，清零触摸按键模块初始化的倒计时
 562   2              touch_cnt_down_clear();
 563   2          }
 564   1      
 565   1          if (KeyOnOutput && 0 == long_touch_flag && cnt < TK_LONG_KEY_TIME) // 如果有按键按下（并且之前扫描到的
             -不是长按）
 566   1          {
 567   2              // 通过循环判断是否为长按
 568   2              for (i = 0; i < 500000; i++) // 实际上用不到这么大的数字，到了设定的长按时间就会退出
 569   2              {
 570   3                  // 按键扫描函数，使用了库里面的接口（闭源库）
 571   3                  // 这个函数会更新__tk_key_flag的值
 572   3                  delay_ms(10);
 573   3                  __tk_scan();
 574   3      
 575   3                  if (KeyOnOutput == __tk_key_flag)
 576   3                  {
 577   4                      // 如果按键键值一致，说明按键一直被按下，未松开
 578   4                      cnt++;
 579   4                  }
 580   3                  else
 581   3                  {
 582   4                      // 如果按键键值不一致或是松开了按键
 583   4                      // cnt = 0;
 584   4                      break;
 585   4                  }
 586   3                  if (cnt > TK_LONG_KEY_TIME) // 如果长按超过了这里设置的时间
 587   3                  {
 588   4                      long_touch_flag = 1; // 标记为长按
 589   4                      break;
 590   4                  }
 591   3              }
 592   2      
 593   2              if (cnt > TK_LONG_KEY_TIME)
 594   2              {
 595   3                  long_touch_flag = 1; // 标记为长按
 596   3              }
 597   2              else
 598   2              {
 599   3                  // 如果是短按
 600   3                  cnt = 0; // 清除长按的计数值
 601   3      
 602   3                  // 判断当前触摸的键值，做对应的操作
 603   3                  if (TK_CH24_VALIB == KeyOnOutput)
 604   3                  {
 605   4                      // 如果KEY1被触摸
 606   4                      for (i = 0; i < send_sp; i++)
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 11  

 607   4                      {
 608   5                          delay_ms(1);
 609   5                          __tk_scan();
 610   5                          KeyOnOutput = __tk_key_flag;
 611   5      
 612   5                          if (TK_CH24_VALIB == KeyOnOutput)
 613   5                          {
 614   6                              // 如果检测到是同一个按键按下，说明是双击
 615   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 616   6                              while (0 != KeyOnOutput)
 617   6                              {
 618   7                                  WDT_KEY = WDT_KEY_VAL(0xAA);
 619   7                                  touch_cnt_down_clear(); // 清零触摸按键模块初始化的倒计时
 620   7                                  __tk_scan();
 621   7                                  KeyOnOutput = __tk_key_flag;
 622   7                              }
 623   6      
 624   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK1);
 625   6      
 626   6      #if USE_MY_DEBUG
                                      printf("K1 double press\n");
              #endif
 629   6                              return;
 630   6                          }
 631   5                      }
 632   4      
 633   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 634   4                      send_status_keyval(KEY_PRESS_SHORT, KEY_TK1); // 发送带有状态的键值
 635   4      #if USE_MY_DEBUG
                              printf("K1 press\n");
              #endif
 638   4                  }
 639   3                  else if (TK_CH3_VALIB == KeyOnOutput)
 640   3                  {
 641   4                      // 如果KEY2被触摸
 642   4                      for (i = 0; i < send_sp; i++)
 643   4                      {
 644   5                          delay_ms(1);
 645   5                          __tk_scan();
 646   5                          KeyOnOutput = __tk_key_flag;
 647   5      
 648   5                          if (TK_CH3_VALIB == KeyOnOutput)
 649   5                          {
 650   6                              // 如果检测到是同一个按键按下，说明是双击
 651   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 652   6                              while (0 != KeyOnOutput)
 653   6                              {
 654   7                                  WDT_KEY = WDT_KEY_VAL(0xAA);
 655   7                                  touch_cnt_down_clear(); // 清零触摸按键模块初始化的倒计时
 656   7                                  __tk_scan();
 657   7                                  KeyOnOutput = __tk_key_flag;
 658   7                              }
 659   6      
 660   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK2);
 661   6      #if USE_MY_DEBUG
                                      printf("K2 double press\n");
              #endif
 664   6                              return;
 665   6                          }
 666   5                      }
 667   4      
 668   4                      // 如果不是同一个按键按下或是没有值，说明是短按
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 12  

 669   4                      send_status_keyval(KEY_PRESS_SHORT, KEY_TK2); // 发送带有状态的键值
 670   4      #if USE_MY_DEBUG
                              printf("K2 press\n");
              #endif
 673   4                  }
 674   3                  else if (TK_CH2_VALIB == KeyOnOutput)
 675   3                  {
 676   4                      // 如果KEY3被触摸
 677   4                      for (i = 0; i < send_sp; i++)
 678   4                      {
 679   5                          delay_ms(1);
 680   5                          __tk_scan();
 681   5                          KeyOnOutput = __tk_key_flag;
 682   5      
 683   5                          if (TK_CH2_VALIB == KeyOnOutput)
 684   5                          {
 685   6                              // 如果检测到是同一个按键按下，说明是双击
 686   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 687   6                              while (0 != KeyOnOutput)
 688   6                              {
 689   7                                  WDT_KEY = WDT_KEY_VAL(0xAA);
 690   7                                  touch_cnt_down_clear(); // 清零触摸按键模块初始化的倒计时
 691   7                                  __tk_scan();
 692   7                                  KeyOnOutput = __tk_key_flag;
 693   7                              }
 694   6      
 695   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK3);
 696   6      #if USE_MY_DEBUG
                                      printf("K3 double press\n");
              #endif
 699   6                              return;
 700   6                          }
 701   5                      }
 702   4      
 703   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 704   4                      send_status_keyval(KEY_PRESS_SHORT, KEY_TK3); // 发送带有状态的键值
 705   4      #if USE_MY_DEBUG
                              printf("K3 press\n");
              #endif
 708   4                  }
 709   3                  else if (TK_CH0_VALIB == KeyOnOutput)
 710   3                  {
 711   4                      // 如果KEY4被触摸
 712   4                      for (i = 0; i < send_sp; i++)
 713   4                      {
 714   5                          delay_ms(1);
 715   5                          __tk_scan();
 716   5                          KeyOnOutput = __tk_key_flag;
 717   5      
 718   5                          if (TK_CH0_VALIB == KeyOnOutput)
 719   5                          {
 720   6                              // 如果检测到是同一个按键按下，说明是双击
 721   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 722   6                              while (0 != KeyOnOutput)
 723   6                              {
 724   7                                  WDT_KEY = WDT_KEY_VAL(0xAA);
 725   7                                  touch_cnt_down_clear(); // 清零触摸按键模块初始化的倒计时
 726   7                                  __tk_scan();
 727   7                                  KeyOnOutput = __tk_key_flag;
 728   7                              }
 729   6      
 730   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK4);
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 13  

 731   6      #if USE_MY_DEBUG
                                      printf("K4 double press\n");
              #endif
 734   6                              return;
 735   6                          }
 736   5                      }
 737   4      
 738   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 739   4                      send_status_keyval(KEY_PRESS_SHORT, KEY_TK4); // 发送带有状态的键值
 740   4      #if USE_MY_DEBUG
                              printf("K4 press\n");
              #endif
 743   4                  }
 744   3                  else if (TK_CH9_VALIB == KeyOnOutput)
 745   3                  {
 746   4                      // 如果KEY5被触摸
 747   4                      for (i = 0; i < send_sp; i++)
 748   4                      {
 749   5                          delay_ms(1);
 750   5                          __tk_scan();
 751   5                          KeyOnOutput = __tk_key_flag;
 752   5      
 753   5                          if (TK_CH9_VALIB == KeyOnOutput)
 754   5                          {
 755   6                              // 如果检测到是同一个按键按下，说明是双击
 756   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 757   6                              while (0 != KeyOnOutput)
 758   6                              {
 759   7                                  WDT_KEY = WDT_KEY_VAL(0xAA);
 760   7                                  touch_cnt_down_clear(); // 清零触摸按键模块初始化的倒计时
 761   7                                  __tk_scan();
 762   7                                  KeyOnOutput = __tk_key_flag;
 763   7                              }
 764   6      
 765   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK5);
 766   6      #if USE_MY_DEBUG
                                      printf("K5 double press\n");
              #endif
 769   6                              return;
 770   6                          }
 771   5                      }
 772   4      
 773   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 774   4                      send_status_keyval(KEY_PRESS_SHORT, KEY_TK5); // 发送带有状态的键值
 775   4      #if USE_MY_DEBUG
                              printf("K5 press\n");
              #endif
 778   4                  }
 779   3                  else if (TK_CH10_VALIB == KeyOnOutput)
 780   3                  {
 781   4                      // 如果KEY6被触摸
 782   4                      for (i = 0; i < send_sp; i++)
 783   4                      {
 784   5                          delay_ms(1);
 785   5                          __tk_scan();
 786   5                          KeyOnOutput = __tk_key_flag;
 787   5      
 788   5                          if (TK_CH10_VALIB == KeyOnOutput)
 789   5                          {
 790   6                              // 如果检测到是同一个按键按下，说明是双击
 791   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 792   6                              while (0 != KeyOnOutput)
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 14  

 793   6                              {
 794   7                                  WDT_KEY = WDT_KEY_VAL(0xAA);
 795   7                                  touch_cnt_down_clear(); // 清零触摸按键模块初始化的倒计时
 796   7                                  __tk_scan();
 797   7                                  KeyOnOutput = __tk_key_flag;
 798   7                              }
 799   6      
 800   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK6);
 801   6      #if USE_MY_DEBUG
                                      printf("K6 double press\n");
              #endif
 804   6                              return;
 805   6                          }
 806   5                      }
 807   4      
 808   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 809   4                      send_status_keyval(KEY_PRESS_SHORT, KEY_TK6); // 发送带有状态的键值
 810   4      #if USE_MY_DEBUG
                              printf("K6 press\n");
              #endif
 813   4                  }
 814   3              }
 815   2          }
 816   1      
 817   1          if (1 == long_touch_flag && 0 != KeyOnOutput)
 818   1          {
 819   2              KeyOld = KeyOnOutput;
 820   2      
 821   2              // 如果之前是长按，现在还未松开
 822   2              // 判断当前触摸的键值，做对应的操作
 823   2              if (TK_CH24_VALIB == KeyOnOutput)
 824   2              {
 825   3                  // 如果KEY1被触摸
 826   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 827   3                  {
 828   4                      send_status_keyval(KEY_PRESS_LONG, KEY_TK1);
 829   4      #if USE_MY_DEBUG
                              printf("K1 long\n");
              #endif
 832   4                  }
 833   3      
 834   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 835   3                  while (0 != KeyOnOutput)
 836   3                  {
 837   4                      delay_ms(10);
 838   4                      cnt++;
 839   4                      __tk_scan();
 840   4                      KeyOnOutput = __tk_key_flag;
 841   4      
 842   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 843   4                      {
 844   5                          cnt = TK_LONG_KEY_TIME;
 845   5                          send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK1);
 846   5      #if USE_MY_DEBUG
                                  printf("K1 hold\n");
              #endif
 849   5                      }
 850   4                  }
 851   3              }
 852   2              else if (TK_CH3_VALIB == KeyOnOutput)
 853   2              {
 854   3                  // 如果KEY2被触摸
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 15  

 855   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 856   3                  {
 857   4                      send_status_keyval(KEY_PRESS_LONG, KEY_TK2);
 858   4      #if USE_MY_DEBUG
                              printf("K2 long\n");
              #endif
 861   4                  }
 862   3      
 863   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 864   3                  while (0 != KeyOnOutput)
 865   3                  {
 866   4                      delay_ms(10);
 867   4                      cnt++;
 868   4                      __tk_scan();
 869   4                      KeyOnOutput = __tk_key_flag;
 870   4      
 871   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 872   4                      {
 873   5                          cnt = TK_LONG_KEY_TIME;
 874   5                          send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK2);
 875   5      #if USE_MY_DEBUG
                                  printf("K2 hold\n");
              #endif
 878   5                      }
 879   4                  }
 880   3      
 881   3                  // display_data ^= 0x0200; // 对应的LED状态取反，后面会调用led_display()刷新
 882   3                  // led_display();          // LED状态更新显示
 883   3              }
 884   2              else if (TK_CH2_VALIB == KeyOnOutput)
 885   2              {
 886   3                  // 如果KEY3被触摸
 887   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 888   3                  {
 889   4                      // display_data ^= 0x0400; // 对应的LED状态取反，后面会调用led_display()刷新
 890   4                      // led_display();          // LED状态更新显示
 891   4                      send_status_keyval(KEY_PRESS_LONG, KEY_TK3);
 892   4      #if USE_MY_DEBUG
                              printf("K3 long\n");
              #endif
 895   4                  }
 896   3      
 897   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 898   3                  while (0 != KeyOnOutput)
 899   3                  {
 900   4                      delay_ms(10);
 901   4                      cnt++;
 902   4                      __tk_scan();
 903   4                      KeyOnOutput = __tk_key_flag;
 904   4      
 905   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 906   4                      {
 907   5                          cnt = TK_LONG_KEY_TIME;
 908   5                          send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK3);
 909   5      #if USE_MY_DEBUG
                                  printf("K3 hold\n");
              #endif
 912   5                      }
 913   4                  }
 914   3      
 915   3                  // display_data ^= 0x0400; // 对应的LED状态取反，后面会调用led_display()刷新
 916   3                  // led_display();          // LED状态更新显示
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 16  

 917   3              }
 918   2              else if (TK_CH0_VALIB == KeyOnOutput)
 919   2              {
 920   3                  // 如果KEY4被触摸
 921   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 922   3                  {
 923   4                      // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 924   4                      // led_display();          // LED状态更新显示
 925   4                      send_status_keyval(KEY_PRESS_LONG, KEY_TK4);
 926   4      #if USE_MY_DEBUG
                              printf("K4 long\n");
              #endif
 929   4                  }
 930   3      
 931   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 932   3                  while (0 != KeyOnOutput)
 933   3                  {
 934   4                      delay_ms(10);
 935   4                      cnt++;
 936   4                      __tk_scan();
 937   4                      KeyOnOutput = __tk_key_flag;
 938   4      
 939   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 940   4                      {
 941   5                          cnt = TK_LONG_KEY_TIME;
 942   5                          send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK4);
 943   5      #if USE_MY_DEBUG
                                  printf("K4 hold\n");
              #endif
 946   5                      }
 947   4                  }
 948   3      
 949   3                  // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 950   3                  // led_display();          // LED状态更新显示
 951   3              }
 952   2              else if (TK_CH9_VALIB == KeyOnOutput)
 953   2              {
 954   3                  // 如果KEY5被触摸
 955   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 956   3                  {
 957   4                      // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 958   4                      // led_display();          // LED状态更新显示
 959   4                      send_status_keyval(KEY_PRESS_LONG, KEY_TK5);
 960   4      #if USE_MY_DEBUG
                              printf("K5 long\n");
              #endif
 963   4                  }
 964   3      
 965   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 966   3                  while (0 != KeyOnOutput)
 967   3                  {
 968   4                      delay_ms(10);
 969   4                      cnt++;
 970   4                      __tk_scan();
 971   4                      KeyOnOutput = __tk_key_flag;
 972   4      
 973   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 974   4                      {
 975   5                          cnt = TK_LONG_KEY_TIME;
 976   5                          send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK5);
 977   5      #if USE_MY_DEBUG
                                  printf("K5 hold\n");
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 17  

              #endif
 980   5                      }
 981   4                  }
 982   3      
 983   3                  // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 984   3                  // led_display();          // LED状态更新显示
 985   3              }
 986   2      
 987   2              else if (TK_CH10_VALIB == KeyOnOutput)
 988   2              {
 989   3                  // 如果KEY6被触摸
 990   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 991   3                  {
 992   4                      // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 993   4                      // led_display();          // LED状态更新显示
 994   4                      send_status_keyval(KEY_PRESS_LONG, KEY_TK6);
 995   4      #if USE_MY_DEBUG
                              printf("K6 long\n");
              #endif
 998   4                  }
 999   3      
1000   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
1001   3                  while (0 != KeyOnOutput)
1002   3                  {
1003   4                      delay_ms(10);
1004   4                      cnt++;
1005   4                      __tk_scan();
1006   4                      KeyOnOutput = __tk_key_flag;
1007   4      
1008   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
1009   4                      {
1010   5                          cnt = TK_LONG_KEY_TIME;
1011   5                          send_status_keyval(KEY_PRESS_CONTINUE, KEY_TK6);
1012   5      #if USE_MY_DEBUG
                                  printf("K6 hold\n");
              #endif
1015   5                      }
1016   4                  }
1017   3      
1018   3                  // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
1019   3                  // led_display();          // LED状态更新显示
1020   3              }
1021   2          }
1022   1          else if (1 == long_touch_flag && 0 == KeyOnOutput)
1023   1          {
1024   2              // 如果之前是长按，现在却松开了按键
1025   2              switch (KeyOld)
1026   2              {
1027   3              case TK_CH24_VALIB:
1028   3                  send_status_keyval(KEY_PRESS_LOOSE, KEY_TK1);
1029   3      #if USE_MY_DEBUG
                          printf("K1 loose\n");
              #endif
1032   3                  break;
1033   3      
1034   3              case TK_CH3_VALIB:
1035   3                  send_status_keyval(KEY_PRESS_LOOSE, KEY_TK2);
1036   3      #if USE_MY_DEBUG
                          printf("K2 loose\n");
              #endif
1039   3                  break;
1040   3      
C51 COMPILER V9.60.7.0   TK_USER                                                           07/10/2025 11:57:30 PAGE 18  

1041   3              case TK_CH2_VALIB:
1042   3                  send_status_keyval(KEY_PRESS_LOOSE, KEY_TK3);
1043   3      #if USE_MY_DEBUG
                          printf("K3 loose\n");
              #endif
1046   3                  break;
1047   3      
1048   3              case TK_CH0_VALIB:
1049   3                  send_status_keyval(KEY_PRESS_LOOSE, KEY_TK4);
1050   3      #if USE_MY_DEBUG
                          printf("K4 loose\n");
              #endif
1053   3                  break;
1054   3      
1055   3              case TK_CH9_VALIB:
1056   3                  send_status_keyval(KEY_PRESS_LOOSE, KEY_TK5);
1057   3      #if USE_MY_DEBUG
                          printf("K5 loose\n");
              #endif
1060   3                  break;
1061   3      
1062   3              case TK_CH10_VALIB:
1063   3                  send_status_keyval(KEY_PRESS_LOOSE, KEY_TK6);
1064   3      #if USE_MY_DEBUG
                          printf("K6 loose\n");
              #endif
1067   3                  break;
1068   3              }
1069   2      
1070   2              long_touch_flag = 0; // 清除标志位
1071   2              cnt = 0;
1072   2              KeyOld = 0;
1073   2          }
1074   1      
1075   1      #if 0
                  if (1 == __tk_long_key_flag) // 如果长按按键（这个功能测试发现不行，不能用）
                  {
                      __tk_long_key_flag = 0;
              
                      // 这里可以自己处理，添加自己需要的功能
              
                      P11 = 0;
                  }
              #endif
1085   1      
1086   1          // led_display(); // LED状态更新显示
1087   1      }
1088          #endif // end of #ifdef CIRCUIT_BOARD
1089          /*************************** (C) COPYRIGHT 2022 TAIXIN-IC ***** END OF FILE *****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1576    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     13      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
