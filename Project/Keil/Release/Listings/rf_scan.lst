C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/10/2025 11:57:31 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\rf_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_scan.l
                    -st) OBJECT(.\Release\Objects\rf_scan.obj)

line level    source

   1          // 扫描RF信号的源文件
   2          #include "rf_scan.h"
   3          
   4          #include "tmr3.h"     // 用来判断按键是短按、长按还是持续的定时器
   5          #include "rf_learn.h" // 使用到了学习得到的、保存在flash中的地址
   6          #include "rf_recv.h"  // RF信号接收
   7          #include "send_key.h" // 发送带有键值的信号
   8          
   9          #include "key_conversion.h" // 将键值转换成功能值（功能值唯一）
  10          
  11          #include "timer0.h"
  12          
  13          // 对RF信号接收引脚进行一次扫描，如果有信号，则进行相应的处理
  14          void rf_scan(void)
  15          {
  16   1          static u8 press_flag = 0;                // 按键状态标志位，0--未按下，1--短按，2--长按，3--持续
  17   1          static volatile u32 timer_total_cnt = 0; // 总计时值，用来判定短按、长按和持续
  18   1      
  19   1          // static u16 send_data = 0; // 存放待发送的数据（测试用/旧版程序使用）
  20   1      
  21   1          static u8 key = 0; // 存放接收到的键值
  22   1      
  23   1      #if 0  // 测试能否接收和发送一个数据帧
                      if (recv_rf_flag)
                      {
                          recv_rf_flag = 0;        // 清除标志位
                          keyval = rf_data & 0x0F; // 记录键值
              
                          send_data = rf_data & 0x0F;
                          send_data |= KEY_PRESS_CONTINUE << 5;
                          send_keyval(send_data);
                          return;
                      }
              #endif // end 测试能否接收和发送一个数据帧
  35   1      
  36   1          if (recv_rf_flag)
  37   1          {
  38   2              // 收到遥控器数据，清空触摸按键模块初始化的倒计时
  39   2              touch_cnt_down_clear();
  40   2      
  41   2              // printf("rf_data %lx\n", rf_data);
  42   2          }
  43   1      
  44   1          if (recv_rf_flag && 0 == timer_total_cnt && 0 == press_flag)
  45   1          {
  46   2              // 如果未按下，记录本次按下的时间
  47   2              recv_rf_flag = 0; // 清除标志位
  48   2      
  49   2              if (1 == rf_addr_isMatch())
  50   2              {
  51   3                  press_flag = 1; // 假设是短按
  52   3      
  53   3      #ifdef DEVELOPMENT_BOARD // 开发板上最后只需要发送遥控器对应的键值
C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/10/2025 11:57:31 PAGE 2   

                          // 记录一次键值
                          key = rf_data & 0x3F;
              #endif // end ifdef DEVELOPMENT_BOARD
  57   3      
  58   3      #ifdef CIRCUIT_BOARD // 目标电路板上需要将遥控器的键值转换成自定义的功能值
  59   3                  // 记录一次键值（实际上是自定义的功能值）
  60   3                  key = key_to_funval(rf_data >> 8, rf_data & 0x3F);
  61   3      #endif // end ifdef CIRCUIT_BOARD
  62   3      
  63   3                  tmr3_enable(); // 打开定时器，开始计数
  64   3              }
  65   2          }
  66   1          else if (timer_total_cnt < 75)
  67   1          {
  68   2              // 如果是短按的判定时间内（这里假设按下并松开了按键的时间是0~750ms之内）
  69   2              if (recv_rf_flag && tmr3_cnt <= 12)
  70   2              {
  71   3                  // 如果收到了信号，并且两次信号的时间不超过120ms
  72   3                  // （哪怕是短按，也会收到若干个信号，这些信号的间隔在13ms左右，
  73   3                  // 一个信号持续时间是40ms左右，这里放宽了判断条件）
  74   3                  recv_rf_flag = 0;
  75   3      
  76   3                  if (1 == rf_addr_isMatch())
  77   3                  {
  78   4      #ifdef DEVELOPMENT_BOARD // 开发板上最后只需要发送遥控器对应的键值
                              // 记录一次键值
                              key = rf_data & 0x3F;
              #endif // end ifdef DEVELOPMENT_BOARD
  82   4      
  83   4      #ifdef CIRCUIT_BOARD // 目标电路板上需要将遥控器的键值转换成自定义的功能值
  84   4                      // 记录一次键值（实际上是自定义的功能值）
  85   4                      key = key_to_funval(rf_data >> 8, rf_data & 0x3F);
  86   4      #endif // end ifdef CIRCUIT_BOARD
  87   4      
  88   4                      timer_total_cnt += tmr3_cnt; // 累计计数时间
  89   4                      tmr3_cnt = 0;                // 清空计数值
  90   4                  }
  91   3              }
  92   2              else if (tmr3_cnt > 12 && press_flag)
  93   2              {
  94   3                  // 如果在120ms范围外，没有收到信号，说明此时已经松开手了，是短按
  95   3                  static u8 old_key = 0; // 存放上一次接收的遥控器按键键值，用于辅助判断双击
  96   3      
  97   3                  press_flag = 0;
  98   3                  timer_total_cnt = 0;
  99   3      
 100   3                  tmr3_disable();
 101   3                  tmr3_cnt = 0;
 102   3      
 103   3                  tmr4_cnt = 0;
 104   3                  tmr4_enable();
 105   3                  old_key = key; // 记录键值，以便下一次判断是否为双击（要两次键值相同）
 106   3      
 107   3                  while (1)
 108   3                  {
 109   4                      if (recv_rf_flag && tmr4_cnt > 50 && tmr4_cnt < 110)
 110   4                      {
 111   5                          // 如果两次按键的时间间隔在50ms~110ms之内，可能有双击
 112   5                          if (old_key == key)
 113   5                          {
 114   6                              // 如果两次按下的键值相等，说明是双击
 115   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, key);
C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/10/2025 11:57:31 PAGE 3   

 116   6                              delay_ms(220);    // 忽略第二次按下时连续发送过来的信号
 117   6                              recv_rf_flag = 0; // 清除标志位
 118   6                              key = 0;
 119   6                              old_key = 0;
 120   6                              return;
 121   6                          }
 122   5                          else
 123   5                          {
 124   6                              // 如果两次按下的键值不相等，说明不是双击
 125   6                              // 这里不清除标志位，可以留到下一次扫描
 126   6                              send_status_keyval(KEY_PRESS_SHORT, old_key);
 127   6                              key = 0;
 128   6                              old_key = 0;
 129   6                              return;
 130   6                          }
 131   5                      }
 132   4                      else if (recv_rf_flag && tmr4_cnt > 110)
 133   4                      {
 134   5                          // 如果两次按下按键的时间间隔超出了110ms，说明不是双击
 135   5                          // 这里不清除标志位，可以留到下一次扫描
 136   5                          send_status_keyval(KEY_PRESS_SHORT, old_key); // 发送带有短按信息的键值
 137   5                          key = 0;
 138   5                          old_key = 0;
 139   5                          return;
 140   5                      }
 141   4                      else if (0 == recv_rf_flag && tmr4_cnt > 110)
 142   4                      {
 143   5                          // 如果超过110ms都没有按下下一个按键，说明是短按
 144   5                          tmr4_disable(); // 关闭定时器
 145   5                          tmr4_cnt = 0;
 146   5                          send_status_keyval(KEY_PRESS_SHORT, old_key); // 发送带有短按信息的键值
 147   5                          key = 0;
 148   5                          old_key = 0;
 149   5                          return;
 150   5                      }
 151   4                  }
 152   3              }
 153   2          }
 154   1          else
 155   1          {
 156   2              // 长按和持续的处理
 157   2              if (1 == press_flag && timer_total_cnt >= 75 && timer_total_cnt < 90)
 158   2              {
 159   3                  // 如果进入到这里，说明按下按键至少有750ms了
 160   3                  // 发送一次带有长按标志的信号
 161   3                  press_flag = 2;
 162   3      
 163   3      #ifdef DEVELOPMENT_BOARD // 开发板上最后只需要发送遥控器对应的键值
              
                          key = rf_data & 0x3F;
              
              #endif // end ifdef DEVELOPMENT_BOARD
 168   3      
 169   3      #ifdef CIRCUIT_BOARD // 目标电路板上需要将遥控器的键值转换成自定义的功能值
 170   3      
 171   3                  // 记录一次键值（实际上是自定义的功能值）
 172   3                  key = key_to_funval(rf_data >> 8, rf_data & 0x3F);
 173   3      
 174   3      #endif // end ifdef CIRCUIT_BOARD
 175   3      
 176   3                  send_status_keyval(KEY_PRESS_LONG, key); // 发送带有长按信息的键值
 177   3      
C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/10/2025 11:57:31 PAGE 4   

 178   3                  press_flag = 3;
 179   3              }
 180   2      
 181   2              if (3 == press_flag && recv_rf_flag && tmr3_cnt <= 12)
 182   2              {
 183   3                  // 如果收到了信号，并且两次信号的时间不超过120ms
 184   3                  // （哪怕是短按，也会收到若干个信号，这些信号的间隔在13ms左右，
 185   3                  // 一个信号持续时间是40ms左右，这里放宽了判断条件）
 186   3                  recv_rf_flag = 0;
 187   3      
 188   3                  if (1 == rf_addr_isMatch())
 189   3                  {
 190   4      #ifdef DEVELOPMENT_BOARD              // 开发板上最后只需要发送遥控器对应的键值
                              key = rf_data & 0x3F; // 记录键值
              #endif                                // end ifdef DEVELOPMENT_BOARD
 193   4      
 194   4      #ifdef CIRCUIT_BOARD // 目标电路板上需要将遥控器的键值转换成自定义的功能值
 195   4                      // 记录一次键值（实际上是自定义的功能值）
 196   4                      key = key_to_funval(rf_data >> 8, rf_data & 0x3F);
 197   4      #endif // end ifdef CIRCUIT_BOARD
 198   4      
 199   4                      timer_total_cnt += tmr3_cnt; // 累计计数时间
 200   4                      tmr3_cnt = 0;                // 清空计数值
 201   4      
 202   4                      // 这里的时间间隔是以每个信号的周期为准，因为判断recv_rf_flag的时候，
 203   4                      // 就是要有信号接收完成这个标志位才会置一，代码才能进入这里
 204   4                      if (timer_total_cnt >= 90)
 205   4                      {
 206   5                          // 清空累计计数时间，发送一次带有持续标志和按键键值的信号
 207   5                          // 接下来每到一定的时间就发送一次带有持续标志和按键键值的信号
 208   5                          send_status_keyval(KEY_PRESS_CONTINUE, key); // 发送带有持续按下消息的16位键值
 209   5                          timer_total_cnt = 75;
 210   5                      }
 211   4                  }
 212   3              }
 213   2              else if (tmr3_cnt > 12 && press_flag)
 214   2              {
 215   3                  // 如果在120ms范围外，没有收到信号，说明此时已经松开手了
 216   3                  // 这里可以发送一次长按后松开的信号
 217   3                  send_status_keyval(KEY_PRESS_LOOSE, key); // 发送长按后松开按键的信号
 218   3      
 219   3                  // 清除标志位和计数值
 220   3                  press_flag = 0;
 221   3                  timer_total_cnt = 0;
 222   3      
 223   3                  tmr3_disable();
 224   3                  tmr3_cnt = 0;
 225   3      
 226   3                  key = 0;
 227   3                  return;
 228   3              }
 229   2          }
 230   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    693    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/10/2025 11:57:31 PAGE 5   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
