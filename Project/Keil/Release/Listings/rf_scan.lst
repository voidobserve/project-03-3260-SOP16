C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/08/2025 17:28:58 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\rf_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_scan.l
                    -st) OBJECT(.\Release\Objects\rf_scan.obj)

line level    source

   1          // 扫描RF信号的源文件
   2          #include "rf_scan.h"
   3          
   4          #include "tmr3.h"     // 用来判断按键是短按、长按还是持续的定时器
   5          #include "rf_learn.h" // 使用到了学习得到的、保存在flash中的地址
   6          #include "rf_recv.h"  // RF信号接收
   7          #include "send_key.h" // 发送带有键值的信号
   8          
   9          #include "key_conversion.h" // 将键值转换成功能值（功能值唯一）
  10          
  11          // 对RF信号接收引脚进行一次扫描，如果有信号，则进行相应的处理
  12          void rf_scan(void)
  13          {
  14   1          static u8 press_flag = 0;                // 按键状态标志位，0--未按下，1--短按，2--长按，3--持续
  15   1          static volatile u32 timer_total_cnt = 0; // 总计时值，用来判定短按、长按和持续
  16   1      
  17   1          // static u16 send_data = 0; // 存放待发送的数据（测试用/旧版程序使用）
  18   1      
  19   1          static u8 key = 0; // 存放接收到的键值
  20   1      
  21   1      #if 0  // 测试能否接收和发送一个数据帧
                      if (recv_rf_flag)
                      {
                          recv_rf_flag = 0;        // 清除标志位
                          keyval = rf_data & 0x0F; // 记录键值
              
                          send_data = rf_data & 0x0F;
                          send_data |= KEY_PRESS_CONTINUE << 5;
                          send_keyval(send_data);
                          return;
                      }
              #endif // end 测试能否接收和发送一个数据帧
  33   1      
  34   1          if (recv_rf_flag)
  35   1          {
  36   2              // 收到遥控器数据，清空触摸按键模块初始化的倒计时
  37   2              touch_cnt_down_clear();
*** WARNING C206 IN LINE 37 OF ..\..\User\rf_scan.c: 'touch_cnt_down_clear': missing function-prototype
  38   2          }
  39   1      
  40   1          if (recv_rf_flag && 0 == timer_total_cnt && 0 == press_flag)
  41   1          {
  42   2              // 如果未按下，记录本次按下的时间
  43   2              recv_rf_flag = 0; // 清除标志位
  44   2      
  45   2              if (1 == rf_addr_isMatch())
  46   2              {
  47   3                  press_flag = 1; // 假设是短按
  48   3      
  49   3      #ifdef DEVELOPMENT_BOARD // 开发板上最后只需要发送遥控器对应的键值
                          // 记录一次键值
                          key = rf_data & 0x3F;
              #endif // end ifdef DEVELOPMENT_BOARD
C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/08/2025 17:28:58 PAGE 2   

  53   3      
  54   3      #ifdef CIRCUIT_BOARD // 目标电路板上需要将遥控器的键值转换成自定义的功能值
  55   3                  // 记录一次键值（实际上是自定义的功能值）
  56   3                  key = key_to_funval(rf_data >> 8, rf_data & 0x3F);
  57   3      #endif // end ifdef CIRCUIT_BOARD
  58   3      
  59   3                  tmr3_enable(); // 打开定时器，开始计数
  60   3              }
  61   2          }
  62   1          else if (timer_total_cnt < 75)
  63   1          {
  64   2              // 如果是短按的判定时间内（这里假设按下并松开了按键的时间是0~750ms之内）
  65   2              if (recv_rf_flag && tmr3_cnt <= 12)
  66   2              {
  67   3                  // 如果收到了信号，并且两次信号的时间不超过120ms
  68   3                  // （哪怕是短按，也会收到若干个信号，这些信号的间隔在13ms左右，
  69   3                  // 一个信号持续时间是40ms左右，这里放宽了判断条件）
  70   3                  recv_rf_flag = 0;
  71   3      
  72   3                  if (1 == rf_addr_isMatch())
  73   3                  {
  74   4      #ifdef DEVELOPMENT_BOARD // 开发板上最后只需要发送遥控器对应的键值
                              // 记录一次键值
                              key = rf_data & 0x3F;
              #endif // end ifdef DEVELOPMENT_BOARD
  78   4      
  79   4      #ifdef CIRCUIT_BOARD // 目标电路板上需要将遥控器的键值转换成自定义的功能值
  80   4                      // 记录一次键值（实际上是自定义的功能值）
  81   4                      key = key_to_funval(rf_data >> 8, rf_data & 0x3F);
  82   4      #endif // end ifdef CIRCUIT_BOARD
  83   4      
  84   4                      timer_total_cnt += tmr3_cnt; // 累计计数时间
  85   4                      tmr3_cnt = 0;                // 清空计数值
  86   4                  }
  87   3              }
  88   2              else if (tmr3_cnt > 12 && press_flag)
  89   2              {
  90   3                  // 如果在120ms范围外，没有收到信号，说明此时已经松开手了，是短按
  91   3                  static u8 old_key = 0; // 存放上一次接收的遥控器按键键值，用于辅助判断双击
  92   3      
  93   3                  press_flag = 0;
  94   3                  timer_total_cnt = 0;
  95   3      
  96   3                  tmr3_disable();
  97   3                  tmr3_cnt = 0;
  98   3      
  99   3                  tmr4_cnt = 0;
 100   3                  tmr4_enable();
 101   3                  old_key = key; // 记录键值，以便下一次判断是否为双击（要两次键值相同）
 102   3      
 103   3                  while (1)
 104   3                  {
 105   4                      if (recv_rf_flag && tmr4_cnt > 50 && tmr4_cnt < 110)
 106   4                      {
 107   5                          // 如果两次按键的时间间隔在50ms~110ms之内，可能有双击
 108   5                          if (old_key == key)
 109   5                          {
 110   6                              // 如果两次按下的键值相等，说明是双击
 111   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, key);
 112   6                              delay_ms(220);    // 忽略第二次按下时连续发送过来的信号
 113   6                              recv_rf_flag = 0; // 清除标志位
 114   6                              key = 0;
C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/08/2025 17:28:58 PAGE 3   

 115   6                              old_key = 0;
 116   6                              return;
 117   6                          }
 118   5                          else
 119   5                          {
 120   6                              // 如果两次按下的键值不相等，说明不是双击
 121   6                              // 这里不清除标志位，可以留到下一次扫描
 122   6                              send_status_keyval(KEY_PRESS_SHORT, old_key);
 123   6                              key = 0;
 124   6                              old_key = 0;
 125   6                              return;
 126   6                          }
 127   5                      }
 128   4                      else if (recv_rf_flag && tmr4_cnt > 110)
 129   4                      {
 130   5                          // 如果两次按下按键的时间间隔超出了110ms，说明不是双击
 131   5                          // 这里不清除标志位，可以留到下一次扫描
 132   5                          send_status_keyval(KEY_PRESS_SHORT, old_key); // 发送带有短按信息的键值
 133   5                          key = 0;
 134   5                          old_key = 0;
 135   5                          return;
 136   5                      }
 137   4                      else if (0 == recv_rf_flag && tmr4_cnt > 110)
 138   4                      {
 139   5                          // 如果超过110ms都没有按下下一个按键，说明是短按
 140   5                          tmr4_disable(); // 关闭定时器
 141   5                          tmr4_cnt = 0;
 142   5                          send_status_keyval(KEY_PRESS_SHORT, old_key); // 发送带有短按信息的键值
 143   5                          key = 0;
 144   5                          old_key = 0;
 145   5                          return;
 146   5                      }
 147   4                  }
 148   3              }
 149   2          }
 150   1          else
 151   1          {
 152   2              // 长按和持续的处理
 153   2              if (1 == press_flag && timer_total_cnt >= 75 && timer_total_cnt < 90)
 154   2              {
 155   3                  // 如果进入到这里，说明按下按键至少有750ms了
 156   3                  // 发送一次带有长按标志的信号
 157   3                  press_flag = 2;
 158   3      
 159   3      #ifdef DEVELOPMENT_BOARD // 开发板上最后只需要发送遥控器对应的键值
              
                          key = rf_data & 0x3F;
              
              #endif // end ifdef DEVELOPMENT_BOARD
 164   3      
 165   3      #ifdef CIRCUIT_BOARD // 目标电路板上需要将遥控器的键值转换成自定义的功能值
 166   3      
 167   3                  // 记录一次键值（实际上是自定义的功能值）
 168   3                  key = key_to_funval(rf_data >> 8, rf_data & 0x3F);
 169   3      
 170   3      #endif // end ifdef CIRCUIT_BOARD
 171   3      
 172   3                  send_status_keyval(KEY_PRESS_LONG, key); // 发送带有长按信息的键值
 173   3      
 174   3                  press_flag = 3;
 175   3              }
 176   2      
C51 COMPILER V9.60.7.0   RF_SCAN                                                           07/08/2025 17:28:58 PAGE 4   

 177   2              if (3 == press_flag && recv_rf_flag && tmr3_cnt <= 12)
 178   2              {
 179   3                  // 如果收到了信号，并且两次信号的时间不超过120ms
 180   3                  // （哪怕是短按，也会收到若干个信号，这些信号的间隔在13ms左右，
 181   3                  // 一个信号持续时间是40ms左右，这里放宽了判断条件）
 182   3                  recv_rf_flag = 0;
 183   3      
 184   3                  if (1 == rf_addr_isMatch())
 185   3                  {
 186   4      #ifdef DEVELOPMENT_BOARD              // 开发板上最后只需要发送遥控器对应的键值
                              key = rf_data & 0x3F; // 记录键值
              #endif                                // end ifdef DEVELOPMENT_BOARD
 189   4      
 190   4      #ifdef CIRCUIT_BOARD // 目标电路板上需要将遥控器的键值转换成自定义的功能值
 191   4                      // 记录一次键值（实际上是自定义的功能值）
 192   4                      key = key_to_funval(rf_data >> 8, rf_data & 0x3F);
 193   4      #endif // end ifdef CIRCUIT_BOARD
 194   4      
 195   4                      timer_total_cnt += tmr3_cnt; // 累计计数时间
 196   4                      tmr3_cnt = 0;                // 清空计数值
 197   4      
 198   4                      // 这里的时间间隔是以每个信号的周期为准，因为判断recv_rf_flag的时候，
 199   4                      // 就是要有信号接收完成这个标志位才会置一，代码才能进入这里
 200   4                      if (timer_total_cnt >= 90)
 201   4                      {
 202   5                          // 清空累计计数时间，发送一次带有持续标志和按键键值的信号
 203   5                          // 接下来每到一定的时间就发送一次带有持续标志和按键键值的信号
 204   5                          send_status_keyval(KEY_PRESS_CONTINUE, key); // 发送带有持续按下消息的16位键值
 205   5                          timer_total_cnt = 75;
 206   5                      }
 207   4                  }
 208   3              }
 209   2              else if (tmr3_cnt > 12 && press_flag)
 210   2              {
 211   3                  // 如果在120ms范围外，没有收到信号，说明此时已经松开手了
 212   3                  // 这里可以发送一次长按后松开的信号
 213   3                  send_status_keyval(KEY_PRESS_LOOSE, key); // 发送长按后松开按键的信号
 214   3      
 215   3                  // 清除标志位和计数值
 216   3                  press_flag = 0;
 217   3                  timer_total_cnt = 0;
 218   3      
 219   3                  tmr3_disable();
 220   3                  tmr3_cnt = 0;
 221   3      
 222   3                  key = 0;
 223   3                  return;
 224   3              }
 225   2          }
 226   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    693    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
